# VirusTotal API integration
try:
    import vt # "pip install --upgrade vt-py" can fix common vt issues
except ModuleNotFoundError:
    exit("Library 'vt' not found! Please install it from via the 'requirements.txt' file with PIP")
import hashlib
from termcolor import *

def connect_to_endpoint(API_key):
    try:
        client_object = vt.Client(API_key)
        return client_object, "success"
    except vt.error.APIError as vt_error:
        return vt_error, "api_fail"
    except Exception as err:
        return err, "general_fail"
 
def craft_api_request(data="", choice="files"):
    choice = choice.lower()
    
    if choice not in ["files", "urls", "search"]:
        return "option_fail"
    
    request_string = ""
    if choice == "files" or choice == "search":
        request_string = f"/{choice}/{data}"
    elif choice == "urls":
        request_string = f"/{choice}/{vt.url_id(data)}"
        
    try:
        # Force typecast to ensure it is string
        return str(request_string)
    except:
        return request_string

def send_api_request(api_string, client_object):
    try:
        output = client_object.get_object(api_string)
        return output, "success"
    except vt.error.APIError as vt_error:
        return vt_error, "api_fail"
    except Exception as err:
        return err, "general_fail"
    finally:
        client_object.close()

def parse_API_error(exception_string):
    error_message = str(exception_string)
    
    if "Resource not found" in error_message:
        return "The requested resource (file or URL) was not found in VirusTotal's database."
    elif "Forbidden" in error_message or "403" in error_message:
        return "Access is forbidden. This might be due to an invalid API key or insufficient permissions."
    elif "Quota exceeded" in error_message or "429" in error_message:
        return "API quota exceeded. You have reached the limit of requests allowed by your API key. Please try again later."
    elif "Bad request" in error_message or "400" in error_message:
        return "Bad request. The request was malformed or missing required parameters."
    elif "Unauthorized" in error_message or "401" in error_message:
        return "Unauthorized access. The API key provided is invalid or missing."
    elif "Internal server error" in error_message or "500" in error_message:
        return "Internal server error. There was an issue on VirusTotal's side. Please try again later."
    elif "Service Unavailable" in error_message or "503" in error_message:
        return "Service unavailable. VirusTotal's service is temporarily unavailable. Please try again later."
    else:
        return f"An unknown error occurred: {error_message}"

def score_verdict(score_value):
    score_value = float(score_value)
    
    if score_value < -10:
        return colored(f"Bad Scoring (Score: {score_value})", 'red')
    elif -10 <= score_value < 0:
        return colored(f"Possibly Bad Scoring (Score: {score_value})", 'yellow')
    elif 0 <= score_value <= 10:
        return colored(f"Neutral Scoring (Score: {score_value})", 'yellow')
    else:
        return colored(f"Good Scoring (Score: {score_value})", 'green')
    
def hash_file(file_data, hash_algo="sha256"):
    if not isinstance(file_data, bytes):
        try:
            file_data = file_data.encode()
        except:
            pass

    hash_object = None
    try:
        if hash_algo == "sha256":
            hash_object = hashlib.sha256(file_data)
        elif hash_algo == "md5":
            hash_object = hashlib.md5(file_data)
        elif hash_algo == "sha1":
            hash_object = hashlib.sha1(file_data)
    except:
        return "hashing_error"

    try:
        return hash_object.hexdigest()
    except:
        return "hash_digest_error"

def final_verdict(last_analysis_result):
    malicious_count = 0
    
    for _, value in last_analysis_result.items():
        if value.get("category") == "malicious":
            malicious_count += 1
    
    if malicious_count < 30:
        print(f"[+] Final Verdict : {colored('Safe', 'green')} (Marked Malicious by less than 30% of vendors)")
    elif malicious_count in range(30,80):
        print(f"[+] Final Verdict : {colored('Possibly Malicious', "yellow")} (Marked Malicious by 30% to 70% of vendors)")
    else:
        print(f"[+] Likely Malicious ({colored('Marked Malicious', "red")} by over 80% of vendors)")

def classify_threat(threat_output):
    categories, labels, threat_names = set(), set(), set()

    for key, value in threat_output.items():
        if key == "suggested_threat_label":
            labels.add(value)
        elif key == "popular_threat_name" and isinstance(value, list):
            for item in value:
                threat_names.add(item.get("value", "Unknown"))
        elif key == "popular_threat_category" and isinstance(value, list):
            for item in value:
                categories.add(item.get("value", "Unknown"))

    print(f"[+] Categories : {colored(', '.join(categories), attrs=['bold'])}")
    print(f"[+] Labels : {colored(', '.join(labels).replace("/", ", "), attrs=['bold'])}")
    print(f"[+] Threat Names : {colored(', '.join(threat_names), attrs=['bold'])}")
        
# Will incorperate more options later on, this is just a basic template
def parse_API_output(choice, output):    
    print("\nScan Overview: ")
    if choice == "files" or choice == "search":
        print(f"[+] File Size : {output.size} bytes")
        print(f"[+] File SHA256 Hash : {output.sha256}")
        print(f"[+] File Type : {output.type_tag}")
        classify_threat(output.popular_threat_classification)
    elif choice == "urls":
        print(f"[+] Times URL Got Scanned : {output.times_submitted}")
        print(f"[+] URL Unique ID : {output.url_id}")
        print(f"[+] Total Community Votes : {output.total_votes}")
    
    print(f"\n{choice.capitalize()} Community Repudation: ")
    print(f"[+] Identified as : {score_verdict(output.reputation)}")

    print("\nSummary of the most recent analysis:")
    last_analysis = output.last_analysis_stats.items()
    for key, value in last_analysis:
        print(f"[+] {key.capitalize()} : {"None" if value == 0 else value} found")
    
    print("\nDetailed results from individual antivirus engines:")    
    av_results = output.last_analysis_results
    for index, (key, value) in enumerate(av_results.items()):
        if index >= 10: break
        category = value.get("category", "Uncategorised")
        print(f"[+] Vendor : {key.capitalize():<20} -> Category : {colored('Malicious', 'red') if category == 'malicious' else category} \t Type : {value.get('result', 'Unknown')}")
    
    print("\nFinal Scan Verdict: ")   
    final_verdict(av_results)

'''
This is just an example of usage - THIS WILL BE DELETED AND IS HERE FOR TESTING PURPOSES 
Since this is a module THERE WILL ONLY BE FUNCTIONS HERE, this will be used in the ransomsniffer.py file
Below is what will be implemented in the file, feel free to experiment if you own an API key!

Note : Error handling will also be considered more in the main program, this is a more basic implementation!
'''     
client_object, _ = connect_to_endpoint("YOUR_API_KEY_HERE") # Insert API key here if you want to test this module
api_request_string = craft_api_request("8d3f68b16f0710f858d8c1d2c699260e6f43161a5510abb0e7ba567bd72c965b", "files") # Data and choice (example of malicious data)
output, function_status = send_api_request(api_request_string, client_object)

if function_status == "api_fail":
    print(parse_API_error(output))
elif function_status == "general_fail":
    print(output)
else:
    # Output API result if no error happens
    parse_API_output("files", output)
    
# VT Documentation : https://virustotal.github.io/vt-py/quickstart.html
